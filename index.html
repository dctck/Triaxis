<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIAXIS Multiplayer v4.3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .lobby {
            padding: 30px;
        }
        
        .lobby-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .game-area {
            padding: 30px;
        }
        
        .round-info {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .players {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .player-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 3px solid #e9ecef;
        }
        
        .player-card.active {
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }
        
        .player-card h2 {
            margin-bottom: 15px;
            color: #667eea;
        }
        
        .resources {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .resource-item {
            background: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 1.1em;
        }
        
        .engines {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .engines strong {
            display: block;
            margin-bottom: 5px;
        }
        
        .dice-area {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .dice-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .die {
            width: 60px;
            height: 60px;
            background: white;
            border: 3px solid #333;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .die:hover:not(.picked) {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .die.picked {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .action-area {
            background: #e7f3ff;
            border: 2px solid #0066cc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            padding: 15px;
            font-size: 1em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #ccc !important;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .upgrade-list {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .upgrade-item {
            padding: 15px;
            margin: 5px 0;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upgrade-item:hover:not(.disabled) {
            border-color: #667eea;
            background: #f8f9fa;
        }
        
        .upgrade-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgrade-item .effect {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        .log-area {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }
        
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .stat-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .hidden {
            display: none;
        }
        
        .draft-effects {
            background: #e7f3ff;
            border: 2px solid #0066cc;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .draft-effects h4 {
            margin-bottom: 10px;
            color: #0066cc;
        }
        
        .game-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .game-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .game-item:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 5px;
            font-size: 1em;
        }
        
        .waiting-message {
            text-align: center;
            padding: 20px;
            background: #fff3cd;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            background: #28a745;
            color: white;
            font-weight: bold;
            z-index: 100;
        }
        
        .connection-status.disconnected {
            background: #dc3545;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">üü¢ Connected</div>
    
    <div class="container">
        <div class="header">
            <h1>üé≤ TRIAXIS Multiplayer v4.0</h1>
            <p>A 2-Player Dice Engine Game</p>
            <p id="playerNameDisplay" style="font-size: 0.9em; margin-top: 10px;"></p>
        </div>
        
        <!-- Lobby Screen -->
        <div class="lobby" id="lobbyScreen">
            <div class="lobby-section">
                <h2>Enter Your Name</h2>
                <div class="input-group">
                    <label>Player Name:</label>
                    <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
                </div>
                <button class="btn btn-primary" onclick="setPlayerName()" style="width: 100%;">Continue</button>
            </div>
        </div>
        
        <!-- Game Selection Screen -->
        <div class="lobby hidden" id="gameSelectionScreen">
            <div class="lobby-section">
                <h2>Create or Join a Game</h2>
                <button class="btn btn-success" onclick="createNewGame()" style="width: 100%; margin-bottom: 10px;">üéÆ Create New Game</button>
                <button class="btn btn-warning" onclick="showJoinByCode()" style="width: 100%; margin-bottom: 10px;">üî¢ Join by Code</button>
                <button class="btn btn-primary" onclick="refreshGameList()" style="width: 100%;">üîÑ Refresh Game List</button>
            </div>
            
            <div class="lobby-section">
                <h3>Available Games</h3>
                <div class="game-list" id="gameList">
                    <p style="text-align: center; color: #666;">Loading games...</p>
                </div>
            </div>
        </div>
        
        <!-- Waiting Room -->
        <div class="lobby hidden" id="waitingRoom">
            <div class="lobby-section">
                <h2>Waiting Room</h2>
                <div class="waiting-message">
                    <h3>Game Code: <span id="gameCodeDisplay"></span></h3>
                    <p style="margin: 10px 0;">Share this code with your friend!</p>
                    <p id="waitingMessage">Waiting for opponent to join...</p>
                    <div id="readySection" class="hidden" style="margin-top: 20px;">
                        <p id="readyStatus" style="margin-bottom: 10px;"></p>
                        <button class="btn btn-success" id="readyBtn" onclick="toggleReady()" style="width: 100%; margin-bottom: 10px;">Ready</button>
                    </div>
                </div>
                <button class="btn btn-danger" onclick="leaveGame()" style="width: 100%;">Leave Game</button>
            </div>
        </div>
        
        <!-- Game Screen -->
        <div class="game-area hidden" id="gameScreen">
            <div class="round-info">
                Round <span id="roundNum">1</span>
                <div style="font-size: 0.6em; margin-top: 5px;" id="turnIndicator"></div>
            </div>
            
            <div class="players">
                <div class="player-card" id="player1Card">
                    <h2 id="player1Name">Player 1</h2>
                    <div class="resources">
                        <div class="resource-item">‚öôÔ∏è Metal: <strong id="p1Metal">0</strong></div>
                        <div class="resource-item">üå± Energy: <strong id="p1Energy">0</strong></div>
                        <div class="resource-item">üìò Insight: <strong id="p1Insight">0</strong></div>
                        <div class="resource-item">‚≠ê VP: <strong id="p1VP">0</strong></div>
                    </div>
                    <div class="resource-item">üì¶ Total: <strong id="p1Total">0</strong></div>
                    <div class="engines">
                        <strong>Engines:</strong>
                        <div>Metal T<span id="p1MetalTier">0</span> | Energy T<span id="p1EnergyTier">0</span> | Insight T<span id="p1InsightTier">0</span></div>
                    </div>
                </div>
                
                <div class="player-card" id="player2Card">
                    <h2 id="player2Name">Player 2</h2>
                    <div class="resources">
                        <div class="resource-item">‚öôÔ∏è Metal: <strong id="p2Metal">0</strong></div>
                        <div class="resource-item">üå± Energy: <strong id="p2Energy">0</strong></div>
                        <div class="resource-item">üìò Insight: <strong id="p2Insight">0</strong></div>
                        <div class="resource-item">‚≠ê VP: <strong id="p2VP">0</strong></div>
                    </div>
                    <div class="resource-item">üì¶ Total: <strong id="p2Total">0</strong></div>
                    <div class="engines">
                        <strong>Engines:</strong>
                        <div>Metal T<span id="p2MetalTier">0</span> | Energy T<span id="p2EnergyTier">0</span> | Insight T<span id="p2InsightTier">0</span></div>
                    </div>
                </div>
            </div>
            
            <div class="dice-area hidden" id="diceArea">
                <h3 id="diceTitle">Rolling dice...</h3>
                <div class="dice-container" id="diceContainer"></div>
                
                <div class="draft-effects hidden" id="draftEffects">
                    <h4>Draft Phase Effects Available:</h4>
                    <div id="draftEffectButtons"></div>
                    <button class="btn btn-secondary" onclick="skipDraftEffects()" style="margin-top: 10px;">Skip / Continue</button>
                </div>
            </div>
            
            <div class="action-area hidden" id="actionArea">
                <h3>Choose Your Action</h3>
                <div class="action-buttons">
                    <button class="btn btn-primary" id="factoryBtn" onclick="showFactoryMenu()">üè≠ View Factory</button>
                    <button class="btn btn-success" id="tradeBtn" onclick="showTradeMenu()">üè™ Trade Post</button>
                    <button class="btn btn-danger" id="denyBtn" onclick="useDenial()">‚öîÔ∏è Insight Denial</button>
                    <button class="btn btn-secondary" onclick="passAction()">‚è≠Ô∏è Pass</button>
                </div>
                <div id="actionDetail" class="hidden"></div>
            </div>
            
            <div class="log-area">
                <h3>Game Log</h3>
                <div id="gameLog"></div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 style="text-align: center; color: #667eea; margin-bottom: 20px;">üèÜ Game Over!</h2>
            <div id="gameOverContent"></div>
            <button class="btn btn-primary" onclick="backToLobby()" style="width: 100%; margin-top: 20px;">Back to Lobby</button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <script>
        // ===== FIREBASE CONFIGURATION =====
        const firebaseConfig = {
            apiKey: "AIzaSyCj4Lq7cYvPY3w-uAFCv7OJME3_Ssej77c",
            authDomain: "triaxis-87e4b.firebaseapp.com",
            databaseURL: "https://triaxis-87e4b-default-rtdb.firebaseio.com",
            projectId: "triaxis-87e4b",
            storageBucket: "triaxis-87e4b.firebasestorage.app",
            messagingSenderId: "83436719282",
            appId: "1:83436719282:web:4264224439f6d926788dab",
            measurementId: "G-SQ467ZT67X"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // ===== GAME STATE =====
        let localPlayer = {
            id: generatePlayerId(),
            name: '',
            playerNumber: null // 1 or 2
        };
        
        let currentGameId = null;
        let gameRef = null;
        let gameListener = null;
        
        // Load from session storage if exists
        function loadSession() {
            const savedSession = sessionStorage.getItem('triaxis_session');
            if (savedSession) {
                try {
                    const session = JSON.parse(savedSession);
                    localPlayer = session.localPlayer;
                    currentGameId = session.currentGameId;
                    
                    if (localPlayer.name && currentGameId) {
                        document.getElementById('playerNameDisplay').textContent = `Playing as: ${localPlayer.name}`;
                        document.getElementById('lobbyScreen').classList.add('hidden');
                        
                        // Try to rejoin the game
                        rejoinGame();
                        return true;
                    }
                } catch (e) {
                    console.error('Error loading session:', e);
                }
            }
            return false;
        }
        
        function saveSession() {
            sessionStorage.setItem('triaxis_session', JSON.stringify({
                localPlayer: localPlayer,
                currentGameId: currentGameId
            }));
        }
        
        function clearSession() {
            sessionStorage.removeItem('triaxis_session');
        }
        
        function rejoinGame() {
            if (!currentGameId) return;
            
            gameRef = database.ref('games/' + currentGameId);
            
            gameRef.once('value').then(snapshot => {
                if (!snapshot.exists()) {
                    alert('Game no longer exists!');
                    clearSession();
                    backToLobby();
                    return;
                }
                
                const gameData = snapshot.val();
                
                // Check if still in game
                if ((localPlayer.playerNumber === 1 && gameData.player1.id === localPlayer.id) ||
                    (localPlayer.playerNumber === 2 && gameData.player2 && gameData.player2.id === localPlayer.id)) {
                    
                    if (gameData.status === 'waiting') {
                        document.getElementById('gameSelectionScreen').classList.add('hidden');
                        document.getElementById('waitingRoom').classList.remove('hidden');
                        document.getElementById('gameCodeDisplay').textContent = gameData.gameCode;
                    } else if (gameData.status === 'active' || gameData.status === 'ready') {
                        document.getElementById('gameSelectionScreen').classList.add('hidden');
                        document.getElementById('waitingRoom').classList.add('hidden');
                        document.getElementById('gameScreen').classList.remove('hidden');
                    }
                    
                    setupGameListener();
                } else {
                    alert('You are no longer in this game!');
                    clearSession();
                    backToLobby();
                }
            }).catch(error => {
                console.error('Error rejoining:', error);
                backToLobby();
            });
        }
        
        // Try to load session on page load
        window.addEventListener('DOMContentLoaded', () => {
            if (!loadSession()) {
                // Show lobby if no session
            }
        });
        
        const engineCosts = {
            metal: {1: {metal: 3}, 2: {metal: 2, energy: 1}, 3: {metal: 5, insight: 1}},
            energy: {1: {energy: 2}, 2: {energy: 1, insight: 1}, 3: {metal: 2, energy: 3}},
            insight: {1: {insight: 2}, 2: {energy: 1, insight: 1}, 3: {metal: 1, insight: 3}}
        };
        
        const engineEffects = {
            metal: {
                1: "Gain +1‚öôÔ∏è at start of each round (PASSIVE)",
                2: "Metal dice (1-2) give +2‚öôÔ∏è instead of 1 (PASSIVE)",
                3: "Gain +2 VP at end of each round (PASSIVE)"
            },
            energy: {
                1: "Convert 1üå± ‚Üí any 1 resource (once per round)",
                2: "Pay 2üå± ‚Üí Gain 1 VP (once per round)",
                3: "Extra action + gain +1 VP per round (PASSIVE VP)"
            },
            insight: {
                1: "Reroll 1 drafted die (once per round, during draft)",
                2: "Change a die by ¬±1 (once per round, during draft)",
                3: "Pay 1üìò ‚Üí Remove 2‚öôÔ∏è from opponent + 1 VP (ACTION)"
            }
        };
        
        // ===== UTILITY FUNCTIONS =====
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
        }
        
        function generateGameCode() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }
        
        function log(message) {
            const logDiv = document.getElementById('gameLog');
            if (!logDiv) return;
            
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logDiv.insertBefore(entry, logDiv.firstChild);
        }
        
        // ===== LOBBY FUNCTIONS =====
        function setPlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter your name!');
                return;
            }
            
            localPlayer.name = name;
            document.getElementById('playerNameDisplay').textContent = `Playing as: ${name}`;
            
            saveSession();
            
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('gameSelectionScreen').classList.remove('hidden');
            
            refreshGameList();
        }
        
        function createNewGame() {
            const gameCode = generateGameCode();
            const gameId = 'game_' + gameCode;
            
            const newGame = {
                gameCode: gameCode,
                status: 'waiting',
                createdAt: firebase.database.ServerValue.TIMESTAMP,
                player1: {
                    id: localPlayer.id,
                    name: localPlayer.name,
                    ready: false,
                    connected: true,
                    metal: 0,
                    energy: 0,
                    insight: 0,
                    vp: 0,
                    metalTier: 0,
                    energyTier: 0,
                    insightTier: 0,
                    metalSpent: 0,
                    trades: 0,
                    denials: 0,
                    denied: 0,
                    usedInsightEffect: false,
                    usedEnergyEffect: false,
                    actionComplete: false,
                    waitingForDraftEffect: false
                },
                player2: null,
                round: 0,
                dice: [],
                player1Dice: [],
                player2Dice: [],
                phase: 'waiting',
                currentPlayer: 1,
                logs: []
            };
            
            database.ref('games/' + gameId).set(newGame)
                .then(() => {
                    currentGameId = gameId;
                    saveSession();
                    joinGame(gameId, 1);
                })
                .catch(error => {
                    alert('Error creating game: ' + error.message);
                });
        }
        
        function refreshGameList() {
            const gameListDiv = document.getElementById('gameList');
            gameListDiv.innerHTML = '<p style="text-align: center; color: #666;">Loading games...</p>';
            
            database.ref('games').orderByChild('status').equalTo('waiting').once('value')
                .then(snapshot => {
                    gameListDiv.innerHTML = '';
                    
                    if (!snapshot.exists()) {
                        gameListDiv.innerHTML = '<p style="text-align: center; color: #666;">No available games. Create one!</p>';
                        return;
                    }
                    
                    snapshot.forEach(childSnapshot => {
                        const game = childSnapshot.val();
                        const gameId = childSnapshot.key;
                        
                        const gameItem = document.createElement('div');
                        gameItem.className = 'game-item';
                        gameItem.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>üéÆ ${game.player1.name}'s Game</strong><br>
                                    <small style="color: #28a745;">‚è≥ Waiting for player...</small>
                                </div>
                                <button class="btn btn-success" style="padding: 8px 16px;">Join</button>
                            </div>
                        `;
                        gameItem.onclick = () => joinGame(gameId, 2);
                        gameListDiv.appendChild(gameItem);
                    });
                })
                .catch(error => {
                    gameListDiv.innerHTML = '<p style="text-align: center; color: red;">Error loading games</p>';
                    console.error(error);
                });
        }
        
        function showJoinByCode() {
            const code = prompt('Enter Game Code:');
            if (!code) return;
            
            const gameId = 'game_' + code.toUpperCase().trim();
            
            database.ref('games/' + gameId).once('value')
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        alert('Game not found! Check the code and try again.');
                        return;
                    }
                    
                    const game = snapshot.val();
                    if (game.status !== 'waiting') {
                        alert('This game is already full or finished!');
                        return;
                    }
                    
                    joinGame(gameId, 2);
                })
                .catch(error => {
                    alert('Error joining game: ' + error.message);
                });
        }
        
        function joinGame(gameId, playerNumber) {
            currentGameId = gameId;
            localPlayer.playerNumber = playerNumber;
            gameRef = database.ref('games/' + gameId);
            
            saveSession();
            
            if (playerNumber === 2) {
                gameRef.child('player2').set({
                    id: localPlayer.id,
                    name: localPlayer.name,
                    ready: false,
                    connected: true,
                    metal: 0,
                    energy: 0,
                    insight: 0,
                    vp: 0,
                    metalTier: 0,
                    energyTier: 0,
                    insightTier: 0,
                    metalSpent: 0,
                    trades: 0,
                    denials: 0,
                    denied: 0,
                    usedInsightEffect: false,
                    usedEnergyEffect: false,
                    actionComplete: false,
                    waitingForDraftEffect: false
                }).then(() => {
                    gameRef.update({
                        status: 'ready' // Both players present
                    });
                    addLog(`${localPlayer.name} joined the game!`);
                });
            }
            
            document.getElementById('gameSelectionScreen').classList.add('hidden');
            document.getElementById('waitingRoom').classList.remove('hidden');
            document.getElementById('gameCodeDisplay').textContent = gameId.replace('game_', '');
            
            setupGameListener();
            setupDisconnectHandler();
        }
        
        function setupDisconnectHandler() {
            const playerKey = 'player' + localPlayer.playerNumber;
            const connectedRef = gameRef.child(playerKey).child('connected');
            
            // Set connected to true
            connectedRef.set(true);
            
            // When I disconnect, set to false and clean up
            connectedRef.onDisconnect().set(false).then(() => {
                // Also mark game as abandoned after 30 seconds if opponent disconnects
                gameRef.child('status').onDisconnect().set('abandoned');
            });
        }
        
        function setupGameListener() {
            gameListener = gameRef.on('value', snapshot => {
                if (!snapshot.exists()) {
                    alert('Game no longer exists!');
                    clearSession();
                    backToLobby();
                    return;
                }
                
                const gameData = snapshot.val();
                
                // Check if opponent disconnected
                if (gameData.status === 'ready' || gameData.status === 'active') {
                    const oppNum = localPlayer.playerNumber === 1 ? 2 : 1;
                    const oppKey = 'player' + oppNum;
                    
                    if (gameData[oppKey] && gameData[oppKey].connected === false) {
                        if (confirm('Your opponent disconnected! Do you want to leave the game?')) {
                            leaveGame();
                        }
                    }
                }
                
                // Check if game was abandoned
                if (gameData.status === 'abandoned') {
                    alert('Game was abandoned.');
                    // Delete the game
                    gameRef.remove();
                    clearSession();
                    backToLobby();
                    return;
                }
                
                updateGameUI(gameData);
            });
        }
        
        function updateGameUI(gameData) {
            // Update connection status
            document.getElementById('connectionStatus').textContent = 'üü¢ Connected';
            document.getElementById('connectionStatus').classList.remove('disconnected');
            
            // If waiting for player 2
            if (gameData.status === 'waiting') {
                document.getElementById('waitingMessage').textContent = 'Waiting for opponent to join...';
                document.getElementById('readySection').classList.add('hidden');
                return;
            }
            
            // If both players present but not started
            if (gameData.status === 'ready') {
                document.getElementById('waitingMessage').textContent = 'Both players joined!';
                document.getElementById('readySection').classList.remove('hidden');
                
                const myReady = gameData['player' + localPlayer.playerNumber].ready;
                const oppReady = gameData['player' + (localPlayer.playerNumber === 1 ? 2 : 1)].ready;
                
                document.getElementById('readyBtn').textContent = myReady ? '‚úì Ready!' : 'Ready';
                document.getElementById('readyBtn').style.background = myReady ? '#28a745' : '#6c757d';
                
                let statusText = '';
                if (myReady && oppReady) {
                    statusText = 'üéÆ Starting game...';
                } else if (myReady) {
                    statusText = '‚è≥ Waiting for opponent to ready up...';
                } else if (oppReady) {
                    statusText = '‚ö° Your opponent is ready!';
                } else {
                    statusText = 'üì¢ Both players click Ready to start!';
                }
                document.getElementById('readyStatus').textContent = statusText;
                
                // Auto-start if both ready
                if (myReady && oppReady && localPlayer.playerNumber === 1) {
                    setTimeout(() => startGame(), 1500);
                }
                
                return;
            }
            
            // Both players connected - show game
            if (gameData.status === 'active' && document.getElementById('waitingRoom').classList.contains('hidden') === false) {
                document.getElementById('waitingRoom').classList.add('hidden');
                document.getElementById('gameScreen').classList.remove('hidden');
            }
            
            // Update player names
            document.getElementById('player1Name').textContent = gameData.player1.name + (localPlayer.playerNumber === 1 ? ' (You)' : '');
            document.getElementById('player2Name').textContent = gameData.player2.name + (localPlayer.playerNumber === 2 ? ' (You)' : '');
            
            // Update player stats
            updatePlayerDisplay(1, gameData.player1);
            updatePlayerDisplay(2, gameData.player2);
            
            // Update round
            document.getElementById('roundNum').textContent = gameData.round;
            
            // Highlight active player (during draft) or both (during action)
            if (gameData.phase === 'action') {
                document.getElementById('player1Card').classList.add('active');
                document.getElementById('player2Card').classList.add('active');
            } else {
                document.getElementById('player1Card').classList.toggle('active', gameData.currentPlayer === 1);
                document.getElementById('player2Card').classList.toggle('active', gameData.currentPlayer === 2);
            }
            
            // Update turn indicator
            if (gameData.phase === 'action') {
                // Will be updated in handleGamePhase with timer
            } else {
                const isMyTurn = gameData.currentPlayer === localPlayer.playerNumber;
                document.getElementById('turnIndicator').textContent = isMyTurn ? 'üü¢ Your Turn' : '‚è≥ Opponent\'s Turn';
            }
            
            // Handle game phases
            handleGamePhase(gameData);
            
            // Start timer updates if in action phase
            if (gameData.phase === 'action') {
                startTimerUpdates();
            } else {
                stopTimerUpdates();
            }
            
            // Update logs
            if (gameData.logs && gameData.logs.length > 0) {
                const logDiv = document.getElementById('gameLog');
                logDiv.innerHTML = '';
                gameData.logs.slice().reverse().slice(0, 20).forEach(logEntry => {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    entry.textContent = logEntry;
                    logDiv.appendChild(entry);
                });
            }
            
            // Check for game over
            if (gameData.status === 'finished') {
                showGameOver(gameData);
            }
        }
        
        function toggleReady() {
            const playerKey = 'player' + localPlayer.playerNumber;
            
            gameRef.child(playerKey).child('ready').once('value').then(snapshot => {
                const currentReady = snapshot.val() || false;
                gameRef.child(playerKey).child('ready').set(!currentReady);
            });
        }
        
        function updatePlayerDisplay(playerNum, playerData) {
            const prefix = 'p' + playerNum;
            document.getElementById(prefix + 'Metal').textContent = playerData.metal;
            document.getElementById(prefix + 'Energy').textContent = playerData.energy;
            document.getElementById(prefix + 'Insight').textContent = playerData.insight;
            document.getElementById(prefix + 'VP').textContent = playerData.vp;
            document.getElementById(prefix + 'Total').textContent = playerData.metal + playerData.energy + playerData.insight;
            document.getElementById(prefix + 'MetalTier').textContent = playerData.metalTier;
            document.getElementById(prefix + 'EnergyTier').textContent = playerData.energyTier;
            document.getElementById(prefix + 'InsightTier').textContent = playerData.insightTier;
        }
        
        function handleGamePhase(gameData) {
            // Reset resolving flag if we're not in action phase anymore
            if (gameData.phase !== 'action') {
                resolvingActionPhase = false;
            }
            
            // Hide all areas first
            document.getElementById('diceArea').classList.add('hidden');
            document.getElementById('actionArea').classList.add('hidden');
            document.getElementById('draftEffects').classList.add('hidden');
            
            if (gameData.phase === 'start') {
                // Show start button only to player 1
                if (localPlayer.playerNumber === 1 && gameData.round === 0) {
                    // Could add a start button here
                }
            } else if (gameData.phase === 'rolling' || gameData.phase.includes('Pick')) {
                document.getElementById('diceArea').classList.remove('hidden');
                
                if (gameData.dice && gameData.dice.length > 0) {
                    // Show whose turn it is in drafting
                    const firstPicker = gameData.round % 2 === 1 ? 1 : 2;
                    let draftStatus = '';
                    
                    if (gameData.phase.includes('Pick1')) {
                        draftStatus = `${gameData['player' + firstPicker].name} picks 1st die`;
                    } else if (gameData.phase.includes('Pick2')) {
                        const secondPicker = firstPicker === 1 ? 2 : 1;
                        draftStatus = `${gameData['player' + secondPicker].name} picks ${gameData.phase.includes('2a') ? '2nd' : '3rd'} die`;
                    }
                    
                    document.getElementById('diceTitle').textContent = `Dice: [${gameData.dice.join(', ')}] - ${draftStatus}`;
                    
                    const canPick = gameData.currentPlayer === localPlayer.playerNumber;
                    displayDice(gameData.dice, canPick);
                }
                
                // Show draft effects if it's my turn and I have them
                const isMyTurn = gameData.currentPlayer === localPlayer.playerNumber;
                const myData = localPlayer.playerNumber === 1 ? gameData.player1 : gameData.player2;
                const myDice = localPlayer.playerNumber === 1 ? gameData.player1Dice : gameData.player2Dice;
                
                // Check if waiting for draft effect decision
                if (myData.waitingForDraftEffect && myDice && myDice.length > 0 && !myData.usedInsightEffect) {
                    if (myData.insightTier >= 1 || myData.insightTier >= 2) {
                        showDraftEffects(myData.insightTier);
                    }
                } else if (isMyTurn && gameData.phase.includes('Pick')) {
                    // Show effects after picking if have them
                    if (myDice && myDice.length > 0 && !myData.usedInsightEffect) {
                        if (myData.insightTier >= 1 || myData.insightTier >= 2) {
                            showDraftEffects(myData.insightTier);
                        }
                    }
                }
            } else if (gameData.phase === 'action') {
                const myData = localPlayer.playerNumber === 1 ? gameData.player1 : gameData.player2;
                const oppData = localPlayer.playerNumber === 1 ? gameData.player2 : gameData.player1;
                
                // Show action area for everyone during action phase
                document.getElementById('actionArea').classList.remove('hidden');
                
                // Calculate time remaining and update display
                if (gameData.actionPhaseStartTime && gameData.actionTimeLimit) {
                    const elapsed = Date.now() - gameData.actionPhaseStartTime;
                    const remaining = Math.max(0, gameData.actionTimeLimit - elapsed);
                    const seconds = Math.ceil(remaining / 1000);
                    
                    // Update turn indicator with timer
                    const timerDisplay = `‚è±Ô∏è ${seconds}s remaining`;
                    
                    if (myData.actionComplete) {
                        document.getElementById('turnIndicator').textContent = `‚úÖ Action complete! Waiting for opponent... ${timerDisplay}`;
                        document.getElementById('actionArea').style.opacity = '0.5';
                        document.getElementById('actionArea').style.pointerEvents = 'none';
                    } else {
                        document.getElementById('turnIndicator').textContent = `üü¢ Your Turn - ${timerDisplay}`;
                        document.getElementById('actionArea').style.opacity = '1';
                        document.getElementById('actionArea').style.pointerEvents = 'auto';
                        updateActionButtons(gameData);
                    }
                    
                    // Check if time expired
                    if (remaining <= 0 && localPlayer.playerNumber === 1 && !resolvingActionPhase) {
                        // Player 1 handles timeout
                        stopTimerUpdates(); // Stop checking once time expires
                        handleActionTimeout();
                    }
                    
                    // Check if both players are done
                    if (myData.actionComplete && oppData.actionComplete) {
                        document.getElementById('turnIndicator').textContent = '‚è≥ Both actions complete! Processing...';
                        
                        // Player 1 advances to next phase (only if not already resolving this action phase)
                        if (localPlayer.playerNumber === 1 && !resolvingActionPhase && gameData.phase === 'action') {
                            stopTimerUpdates(); // Stop timer updates
                            setTimeout(() => {
                                resolveActionPhase();
                            }, 1000);
                        }
                    }
                }
            }
        }
        
        // Start timer update interval when game loads
        let timerUpdateInterval = null;
        
        function startTimerUpdates() {
            // Clear any existing interval
            if (timerUpdateInterval) {
                clearInterval(timerUpdateInterval);
            }
            
            // Update every second
            timerUpdateInterval = setInterval(() => {
                gameRef.once('value').then(snapshot => {
                    const gameData = snapshot.val();
                    if (gameData && gameData.phase === 'action') {
                        handleGamePhase(gameData);
                    }
                });
            }, 1000);
        }
        
        function stopTimerUpdates() {
            if (timerUpdateInterval) {
                clearInterval(timerUpdateInterval);
                timerUpdateInterval = null;
            }
        }
        
        let timeoutHandled = false;
        let resolvingActionPhase = false;
        
        function handleActionTimeout() {
            if (timeoutHandled) return; // Already handled
            timeoutHandled = true;
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                
                // Auto-pass for players who didn't act
                const updates = {};
                
                if (!gameData.player1.actionComplete) {
                    updates['player1/actionComplete'] = true;
                    addLog(`${gameData.player1.name} passed (time expired)`);
                }
                
                if (!gameData.player2.actionComplete) {
                    updates['player2/actionComplete'] = true;
                    addLog(`${gameData.player2.name} passed (time expired)`);
                }
                
                if (Object.keys(updates).length > 0) {
                    gameRef.update(updates).then(() => {
                        setTimeout(() => {
                            resolveActionPhase();
                        }, 1000);
                    });
                } else {
                    // Both already completed, just resolve
                    setTimeout(() => {
                        resolveActionPhase();
                    }, 1000);
                }
            });
        }
        
        function resolveActionPhase() {
            console.log('resolveActionPhase called, playerNum:', localPlayer.playerNumber, 'resolvingFlag:', resolvingActionPhase);
            
            if (localPlayer.playerNumber !== 1) return; // Only player 1 resolves
            if (resolvingActionPhase) {
                console.log('Already resolving, skipping');
                return; // Already resolving
            }
            
            console.log('Starting to resolve action phase');
            resolvingActionPhase = true;
            
            applyEndOfRoundEffects();
            
            setTimeout(() => {
                checkWinCondition();
            }, 1000);
        }
        
        function displayDice(dice, canPick) {
            const container = document.getElementById('diceContainer');
            container.innerHTML = '';
            
            dice.forEach((die, index) => {
                const dieDiv = document.createElement('div');
                dieDiv.className = 'die';
                if (!canPick) dieDiv.classList.add('picked');
                dieDiv.textContent = die;
                if (canPick) {
                    dieDiv.onclick = () => pickDie(index);
                }
                container.appendChild(dieDiv);
            });
        }
        
        function showDraftEffects(insightTier) {
            const effectsDiv = document.getElementById('draftEffects');
            const buttonsDiv = document.getElementById('draftEffectButtons');
            
            let html = '';
            
            if (insightTier >= 1) {
                html += '<button class="btn btn-warning" style="margin: 5px;" onclick="useReroll()">üîÑ Reroll Last Die</button>';
            }
            
            if (insightTier >= 2) {
                html += '<button class="btn btn-warning" style="margin: 5px;" onclick="useDieChange()">‚ÜïÔ∏è Change Last Die ¬±1</button>';
            }
            
            buttonsDiv.innerHTML = html;
            effectsDiv.classList.remove('hidden');
        }
        
        function updateActionButtons(gameData) {
            const myData = localPlayer.playerNumber === 1 ? gameData.player1 : gameData.player2;
            const oppData = localPlayer.playerNumber === 1 ? gameData.player2 : gameData.player1;
            
            const canTrade = myData.metal >= 3 || myData.energy >= 3 || myData.insight >= 3;
            document.getElementById('tradeBtn').disabled = !canTrade;
            
            const canDeny = myData.insightTier >= 3 && myData.insight >= 1 && oppData.metal >= 2;
            document.getElementById('denyBtn').disabled = !canDeny;
        }
        
        // ===== GAME ACTIONS =====
        function startGame() {
            if (localPlayer.playerNumber !== 1) return;
            
            const firstPicker = 1; // Round 1, player 1 goes first
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                
                gameRef.update({
                    status: 'active',
                    round: 1,
                    phase: 'rolling',
                    dice: rollDice(),
                    player1Dice: [],
                    player2Dice: [],
                    currentPlayer: firstPicker
                });
                
                addLog('Game started! Round 1');
                addLog(`${gameData.player1.name} picks first this round`);
                
                // Apply passive effects
                applyStartOfRoundEffects();
                
                setTimeout(() => {
                    gameRef.update({
                        phase: 'player' + firstPicker + 'Pick1'
                    });
                }, 1000);
            });
        }
        
        function rollDice() {
            return Array.from({length: 4}, () => Math.floor(Math.random() * 6) + 1);
        }
        
        function pickDie(index) {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                
                if (gameData.currentPlayer !== localPlayer.playerNumber) {
                    alert('Not your turn!');
                    return;
                }
                
                const die = gameData.dice[index];
                const newDice = [...gameData.dice];
                newDice.splice(index, 1);
                
                const playerKey = 'player' + localPlayer.playerNumber;
                const diceKey = playerKey + 'Dice';
                const newPlayerDice = [...(gameData[diceKey] || []), die];
                
                const updates = {
                    dice: newDice,
                    [diceKey]: newPlayerDice
                };
                
                addLog(`${localPlayer.name} picked: ${die}`);
                
                // Snake draft: P1 picks 1st, P2 picks 2nd and 3rd, P1 gets 4th (last)
                const firstPicker = gameData.round % 2 === 1 ? 1 : 2; // Alternates who goes first
                const myData = gameData[playerKey];
                
                // Check if player has insight effects available
                const hasInsightEffects = (myData.insightTier >= 1 || myData.insightTier >= 2) && !myData.usedInsightEffect;
                
                if (gameData.phase === 'player' + firstPicker + 'Pick1') {
                    // First picker took 1st die, now second picker gets 2 picks
                    const secondPicker = firstPicker === 1 ? 2 : 1;
                    
                    if (hasInsightEffects) {
                        // Set waiting flag, don't change phase yet
                        updates[playerKey + '/waitingForDraftEffect'] = true;
                    } else {
                        // No effects, proceed to next phase
                        updates.phase = 'player' + secondPicker + 'Pick2a';
                        updates.currentPlayer = secondPicker;
                    }
                    
                } else if (gameData.phase === 'player' + localPlayer.playerNumber + 'Pick2a') {
                    // Second picker took their first die, still their turn for 2nd die
                    
                    if (hasInsightEffects) {
                        // Set waiting flag, don't change phase yet
                        updates[playerKey + '/waitingForDraftEffect'] = true;
                    } else {
                        // No effects, proceed to pick second die
                        updates.phase = 'player' + localPlayer.playerNumber + 'Pick2b';
                    }
                    
                } else if (gameData.phase === 'player' + localPlayer.playerNumber + 'Pick2b') {
                    // Second picker took both dice, first picker gets last die automatically
                    const lastDie = newDice[0];
                    const firstPickerKey = 'player' + firstPicker;
                    const firstPickerDiceKey = firstPickerKey + 'Dice';
                    
                    updates[firstPickerDiceKey] = [...gameData[firstPickerDiceKey], lastDie];
                    updates.dice = [];
                    
                    addLog(`${gameData[firstPickerKey].name} gets last die: ${lastDie}`);
                    
                    if (hasInsightEffects) {
                        // Set waiting flag for second picker
                        updates[playerKey + '/waitingForDraftEffect'] = true;
                        // Also set waiting flag for first picker who just got last die
                        const firstPickerData = gameData[firstPickerKey];
                        const firstPickerHasEffects = (firstPickerData.insightTier >= 1 || firstPickerData.insightTier >= 2) && !firstPickerData.usedInsightEffect;
                        if (firstPickerHasEffects) {
                            updates[firstPickerKey + '/waitingForDraftEffect'] = true;
                        }
                        // Don't finish drafting yet
                    } else {
                        // Check if first picker needs to wait for effects
                        const firstPickerData = gameData[firstPickerKey];
                        const firstPickerHasEffects = (firstPickerData.insightTier >= 1 || firstPickerData.insightTier >= 2) && !firstPickerData.usedInsightEffect;
                        
                        if (firstPickerHasEffects) {
                            updates[firstPickerKey + '/waitingForDraftEffect'] = true;
                        } else {
                            // Nobody waiting, finish drafting
                            gameRef.update(updates).then(() => {
                                setTimeout(() => finishDrafting(), 500);
                            });
                            return;
                        }
                    }
                }
                
                gameRef.update(updates);
            });
        }
        
        function finishDrafting() {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                
                // Convert dice to resources
                const p1Resources = convertDiceToResources(gameData.player1Dice, gameData.player1);
                const p2Resources = convertDiceToResources(gameData.player2Dice, gameData.player2);
                
                const now = Date.now();
                
                // Reset flags for new action phase
                timeoutHandled = false;
                resolvingActionPhase = false;
                
                gameRef.update({
                    'player1/metal': p1Resources.metal,
                    'player1/energy': p1Resources.energy,
                    'player1/insight': p1Resources.insight,
                    'player1/actionComplete': false,
                    'player2/metal': p2Resources.metal,
                    'player2/energy': p2Resources.energy,
                    'player2/insight': p2Resources.insight,
                    'player2/actionComplete': false,
                    phase: 'action',
                    actionPhaseStartTime: now,
                    actionTimeLimit: 60000 // 60 seconds = 1 minute
                });
                
                addLog(`Drafting complete! Both players take actions simultaneously.`);
                addLog(`‚è∞ You have 1 minute to complete your action!`);
            });
        }
        
        function convertDiceToResources(dice, playerData) {
            let metal = playerData.metal || 0;
            let energy = playerData.energy || 0;
            let insight = playerData.insight || 0;
            
            dice.forEach(die => {
                if (die <= 2) {
                    const amount = playerData.metalTier >= 2 ? 2 : 1;
                    metal += amount;
                } else if (die <= 4) {
                    energy += 1;
                } else {
                    insight += 1;
                }
            });
            
            return { metal, energy, insight };
        }
        
        function skipDraftEffects() {
            const playerKey = 'player' + localPlayer.playerNumber;
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const updates = {
                    [playerKey + '/waitingForDraftEffect']: false
                };
                
                // Determine what phase we're in and where to go next
                const firstPicker = gameData.round % 2 === 1 ? 1 : 2;
                const secondPicker = firstPicker === 1 ? 2 : 1;
                
                if (gameData.phase === 'player' + firstPicker + 'Pick1') {
                    // First picker skipped effect, move to second picker
                    updates.phase = 'player' + secondPicker + 'Pick2a';
                    updates.currentPlayer = secondPicker;
                    
                } else if (gameData.phase === 'player' + secondPicker + 'Pick2a') {
                    // Second picker skipped effect on first die, let them pick second die
                    updates.phase = 'player' + secondPicker + 'Pick2b';
                    
                } else if (gameData.phase === 'player' + secondPicker + 'Pick2b' || gameData.dice.length === 0) {
                    // Second picker finished or last die already assigned
                    // Check if both players are done waiting for effects
                    const p1Waiting = gameData.player1.waitingForDraftEffect;
                    const p2Waiting = gameData.player2.waitingForDraftEffect;
                    
                    if (localPlayer.playerNumber === 1) {
                        updates['player1/waitingForDraftEffect'] = false;
                    } else {
                        updates['player2/waitingForDraftEffect'] = false;
                    }
                    
                    // Check if other player is also done
                    const otherPlayerStillWaiting = localPlayer.playerNumber === 1 ? p2Waiting : p1Waiting;
                    
                    if (!otherPlayerStillWaiting) {
                        // Both done, finish drafting
                        gameRef.update(updates).then(() => {
                            setTimeout(() => finishDrafting(), 500);
                        });
                        return;
                    }
                }
                
                gameRef.update(updates);
                document.getElementById('draftEffects').classList.add('hidden');
            });
        }
        
        function useReroll() {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const playerKey = 'player' + localPlayer.playerNumber;
                const diceKey = playerKey + 'Dice';
                const myDice = gameData[diceKey];
                
                if (!myDice || myDice.length === 0) return;
                
                const lastIndex = myDice.length - 1;
                const oldDie = myDice[lastIndex];
                const newDie = Math.floor(Math.random() * 6) + 1;
                
                const newDice = [...myDice];
                newDice[lastIndex] = newDie;
                
                gameRef.update({
                    [diceKey]: newDice,
                    [playerKey + '/usedInsightEffect']: true
                });
                
                addLog(`${localPlayer.name} rerolled ${oldDie} ‚Üí ${newDie}`);
                skipDraftEffects();
            });
        }
        
        function useDieChange() {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const playerKey = 'player' + localPlayer.playerNumber;
                const diceKey = playerKey + 'Dice';
                const myDice = gameData[diceKey];
                
                if (!myDice || myDice.length === 0) return;
                
                const lastDie = myDice[myDice.length - 1];
                
                const change = confirm(`Change die ${lastDie}. Press OK for +1, Cancel for -1`);
                const newValue = change ? Math.min(6, lastDie + 1) : Math.max(1, lastDie - 1);
                
                const newDice = [...myDice];
                newDice[newDice.length - 1] = newValue;
                
                gameRef.update({
                    [diceKey]: newDice,
                    [playerKey + '/usedInsightEffect']: true
                });
                
                addLog(`${localPlayer.name} changed ${lastDie} ‚Üí ${newValue}`);
                skipDraftEffects();
            });
        }
        
        function showFactoryMenu() {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const myKey = 'player' + localPlayer.playerNumber;
                const myData = gameData[myKey];
                
                if (myData.actionComplete) {
                    alert('You already completed your action!');
                    return;
                }
                
                const detail = document.getElementById('actionDetail');
                detail.className = '';
                
                let html = '<div class="upgrade-list">';
                
                html += '<h4>üè≠ Your Current Engines</h4>';
                
                const families = ['metal', 'energy', 'insight'];
                let hasAnyEngine = false;
                
                families.forEach(family => {
                    const tier = myData[family + 'Tier'];
                    if (tier > 0) {
                        hasAnyEngine = true;
                        const familyName = family.charAt(0).toUpperCase() + family.slice(1);
                        const icon = family === 'metal' ? '‚öôÔ∏è' : family === 'energy' ? 'üå±' : 'üìò';
                        
                        html += `<div style="background: white; padding: 15px; margin: 10px 0; border-radius: 8px; border: 2px solid #667eea;">`;
                        html += `<strong>${icon} ${familyName} - Tier ${tier}</strong><br>`;
                        
                        for (let i = 1; i <= tier; i++) {
                            const effect = engineEffects[family][i];
                            html += `<div style="margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 5px;">`;
                            html += `Tier ${i}: ${effect}`;
                            html += `</div>`;
                        }
                        
                        html += `</div>`;
                    }
                });
                
                if (!hasAnyEngine) {
                    html += '<p style="color: #666; font-style: italic;">No engines built yet.</p>';
                }
                
                html += '<h4 style="margin-top: 20px;">üìà Available Upgrades</h4>';
                
                families.forEach(family => {
                    const currentTier = myData[family + 'Tier'];
                    const nextTier = currentTier + 1;
                    
                    if (nextTier <= 3) {
                        const cost = engineCosts[family][nextTier];
                        const canAfford = canAffordUpgrade(myData, family, nextTier);
                        const costText = Object.entries(cost).map(([res, amt]) => 
                            `${amt}${res === 'metal' ? '‚öôÔ∏è' : res === 'energy' ? 'üå±' : 'üìò'}`
                        ).join(' + ');
                        
                        const vpGain = family === 'metal' ? 0 : 1;
                        const effect = engineEffects[family][nextTier];
                        const familyName = family.charAt(0).toUpperCase() + family.slice(1);
                        
                        html += `<div class="upgrade-item ${!canAfford ? 'disabled' : ''}" onclick="${canAfford ? `buyUpgrade('${family}', ${nextTier})` : ''}">
                            <strong>${familyName} Tier ${nextTier}</strong> (+${vpGain} VP)
                            <br>Cost: ${costText}
                            <div class="effect">Effect: ${effect}</div>
                        </div>`;
                    }
                });
                
                html += '<button class="btn btn-secondary" onclick="closeActionDetail()" style="margin-top: 15px; width: 100%;">Close</button>';
                html += '</div>';
                detail.innerHTML = html;
            });
        }
        
        function canAffordUpgrade(player, family, tier) {
            const cost = engineCosts[family][tier];
            return (!cost.metal || player.metal >= cost.metal) &&
                   (!cost.energy || player.energy >= cost.energy) &&
                   (!cost.insight || player.insight >= cost.insight);
        }
        
        function buyUpgrade(family, tier) {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const myKey = 'player' + localPlayer.playerNumber;
                const myData = gameData[myKey];
                const cost = engineCosts[family][tier];
                
                const updates = {};
                
                if (cost.metal) {
                    updates[myKey + '/metal'] = myData.metal - cost.metal;
                    updates[myKey + '/metalSpent'] = (myData.metalSpent || 0) + cost.metal;
                }
                if (cost.energy) {
                    updates[myKey + '/energy'] = myData.energy - cost.energy;
                }
                if (cost.insight) {
                    updates[myKey + '/insight'] = myData.insight - cost.insight;
                }
                
                updates[myKey + '/' + family + 'Tier'] = tier;
                
                const vpGain = family === 'metal' ? 0 : 1;
                updates[myKey + '/vp'] = myData.vp + vpGain;
                updates[myKey + '/actionComplete'] = true;
                
                gameRef.update(updates);
                
                addLog(`${localPlayer.name} bought ${family.charAt(0).toUpperCase() + family.slice(1)} Tier ${tier}! (+${vpGain} VP)`);
                
                closeActionDetail();
            });
        }
        
        function closeActionDetail() {
            document.getElementById('actionDetail').classList.add('hidden');
            document.getElementById('actionDetail').innerHTML = '';
        }
        
        function showTradeMenu() {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const myKey = 'player' + localPlayer.playerNumber;
                const myData = gameData[myKey];
                
                if (myData.actionComplete) {
                    alert('You already completed your action!');
                    return;
                }
                
                const detail = document.getElementById('actionDetail');
                detail.className = '';
                
                if (myData.metal < 3 && myData.energy < 3 && myData.insight < 3) {
                    alert('Need 3 of any resource!');
                    return;
                }
                
                let html = '<div class="upgrade-list"><h4>üè™ Trade Post</h4>';
                html += '<p style="margin-bottom: 15px;">Trade 3 of one resource for 2 different resources</p>';
                
                html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
                html += '<h5 style="margin-bottom: 10px;">Step 1: Choose what to trade away (need 3)</h5>';
                html += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';
                
                if (myData.metal >= 3) {
                    html += '<button class="btn btn-warning" style="flex: 1; min-width: 100px;" onclick="selectTradeFrom(\'metal\')">Trade 3‚öôÔ∏è Metal</button>';
                } else {
                    html += `<button class="btn" style="flex: 1; min-width: 100px; background: #ddd;" disabled>3‚öôÔ∏è Metal (need ${3 - myData.metal} more)</button>`;
                }
                
                if (myData.energy >= 3) {
                    html += '<button class="btn btn-warning" style="flex: 1; min-width: 100px;" onclick="selectTradeFrom(\'energy\')">Trade 3üå± Energy</button>';
                } else {
                    html += `<button class="btn" style="flex: 1; min-width: 100px; background: #ddd;" disabled>3üå± Energy (need ${3 - myData.energy} more)</button>`;
                }
                
                if (myData.insight >= 3) {
                    html += '<button class="btn btn-warning" style="flex: 1; min-width: 100px;" onclick="selectTradeFrom(\'insight\')">Trade 3üìò Insight</button>';
                } else {
                    html += `<button class="btn" style="flex: 1; min-width: 100px; background: #ddd;" disabled>3üìò Insight (need ${3 - myData.insight} more)</button>`;
                }
                
                html += '</div></div>';
                
                html += '<div id="tradeStep2" style="display:none;">';
                html += '<div style="background: #e7f3ff; padding: 15px; border-radius: 8px;">';
                html += '<h5 style="margin-bottom: 10px;">Step 2: Choose 2 resources to receive</h5>';
                html += '<div id="tradeReceiveButtons"></div>';
                html += '</div></div>';
                
                html += '<button class="btn btn-secondary" onclick="closeActionDetail()" style="margin-top: 15px; width: 100%;">Close</button>';
                html += '</div>';
                detail.innerHTML = html;
            });
        }
        
        let tradeState = {from: null, to: []};
        
        function selectTradeFrom(resource) {
            tradeState.from = resource;
            tradeState.to = [];
            
            const icon = resource === 'metal' ? '‚öôÔ∏è' : resource === 'energy' ? 'üå±' : 'üìò';
            document.getElementById('tradeStep2').style.display = 'block';
            
            const receiveDiv = document.getElementById('tradeReceiveButtons');
            receiveDiv.innerHTML = `<p style="margin-bottom: 10px;">Trading away: <strong>3${icon}</strong> | Select 2 to receive:</p>`;
            
            const resources = [
                {value: 'metal', label: '‚öôÔ∏è Metal'},
                {value: 'energy', label: 'üå± Energy'},
                {value: 'insight', label: 'üìò Insight'}
            ];
            
            let buttonsHtml = '<div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">';
            resources.forEach(res => {
                if (res.value !== resource) {
                    buttonsHtml += `<button class="btn btn-success" id="receive_${res.value}" style="flex: 1; min-width: 100px;" onclick="toggleReceive('${res.value}')">${res.label}</button>`;
                }
            });
            buttonsHtml += '</div>';
            
            buttonsHtml += '<div id="selectedResources" style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px; min-height: 40px;"></div>';
            buttonsHtml += '<div style="display: flex; gap: 10px; margin-top: 10px;">';
            buttonsHtml += '<button class="btn btn-secondary" style="flex: 1;" onclick="resetTradeSelection()">Reset Selection</button>';
            buttonsHtml += '<button class="btn btn-primary" id="confirmTradeBtn" style="flex: 1;" onclick="confirmTrade()" disabled>Confirm Trade</button>';
            buttonsHtml += '</div>';
            
            receiveDiv.innerHTML += buttonsHtml;
            updateTradeDisplay();
        }

        function resetTradeSelection() {
            tradeState.to = [];
            updateTradeDisplay();
        }
        
        function toggleReceive(resource) {
            const index = tradeState.to.indexOf(resource);
            
            if (index >= 0) {
                tradeState.to.splice(index, 1);
            } else {
                if (tradeState.to.length < 2) {
                    tradeState.to.push(resource);
                }
            }
            
            updateTradeDisplay();
        }
        
        function updateTradeDisplay() {
            const resources = [
                {value: 'metal', label: '‚öôÔ∏è Metal'},
                {value: 'energy', label: 'üå± Energy'},
                {value: 'insight', label: 'üìò Insight'}
            ];
            
            resources.forEach(res => {
                const btn = document.getElementById(`receive_${res.value}`);
                if (btn) {
                    if (tradeState.to.includes(res.value)) {
                        btn.style.background = '#28a745';
                        btn.style.transform = 'scale(1.05)';
                        btn.style.boxShadow = '0 0 10px rgba(40, 167, 69, 0.5)';
                    } else {
                        btn.style.background = '';
                        btn.style.transform = '';
                        btn.style.boxShadow = '';
                    }
                }
            });
            
            const selectedDiv = document.getElementById('selectedResources');
            if (selectedDiv) {
                if (tradeState.to.length === 0) {
                    selectedDiv.innerHTML = '<em style="color: #999;">Select 2 resources to receive...</em>';
                } else {
                    const icons = tradeState.to.map(r => {
                        return r === 'metal' ? '‚öôÔ∏è Metal' : r === 'energy' ? 'üå± Energy' : 'üìò Insight';
                    });
                    selectedDiv.innerHTML = `<strong>You will receive:</strong> ${icons.join(' + ')} ${tradeState.to.length < 2 ? '(select 1 more)' : '‚úì'}`;
                }
            }
            
            const confirmBtn = document.getElementById('confirmTradeBtn');
            if (confirmBtn) {
                confirmBtn.disabled = tradeState.to.length !== 2;
            }
        }
        
        function confirmTrade() {
            if (tradeState.to.length !== 2) {
                alert('Select exactly 2 resources!');
                return;
            }
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const myKey = 'player' + localPlayer.playerNumber;
                const myData = gameData[myKey];
                
                const updates = {};
                updates[myKey + '/' + tradeState.from] = myData[tradeState.from] - 3;
                updates[myKey + '/metalSpent'] = (myData.metalSpent || 0) + (tradeState.from === 'metal' ? 3 : 0);
                updates[myKey + '/trades'] = (myData.trades || 0) + 1;
                
                tradeState.to.forEach(resource => {
                    updates[myKey + '/' + resource] = myData[resource] + 1;
                });
                
                updates[myKey + '/actionComplete'] = true;
                
                gameRef.update(updates);
                
                const fromIcon = tradeState.from === 'metal' ? '‚öôÔ∏è' : tradeState.from === 'energy' ? 'üå±' : 'üìò';
                const toIcons = tradeState.to.map(r => r === 'metal' ? '‚öôÔ∏è' : r === 'energy' ? 'üå±' : 'üìò');
                
                addLog(`${localPlayer.name} traded 3${fromIcon} for ${toIcons[0]} and ${toIcons[1]}`);
                
                tradeState = {from: null, to: []};
                closeActionDetail();
            });
        }
        
        function useDenial() {
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const myKey = 'player' + localPlayer.playerNumber;
                const oppKey = 'player' + (localPlayer.playerNumber === 1 ? 2 : 1);
                const myData = gameData[myKey];
                const oppData = gameData[oppKey];
                
                if (myData.insightTier < 3 || myData.insight < 1 || oppData.metal < 2) {
                    alert('Cannot use Insight Denial!');
                    return;
                }
                
                gameRef.update({
                    [myKey + '/insight']: myData.insight - 1,
                    [myKey + '/vp']: myData.vp + 1,
                    [myKey + '/denials']: (myData.denials || 0) + 1,
                    [myKey + '/denied']: (myData.denied || 0) + 2,
                    [myKey + '/actionComplete']: true,
                    [oppKey + '/metal']: oppData.metal - 2
                });
                
                addLog(`${localPlayer.name} used Insight Denial!`);
            });
        }
        
        function passAction() {
            const playerKey = 'player' + localPlayer.playerNumber;
            
            gameRef.update({
                [playerKey + '/actionComplete']: true
            });
            
            addLog(`${localPlayer.name} passed`);
        }
        
        function applyStartOfRoundEffects() {
            if (localPlayer.playerNumber !== 1) return; // Only player 1 applies effects
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const updates = {};
                
                if (gameData.player1.metalTier >= 1) {
                    updates['player1/metal'] = gameData.player1.metal + 1;
                    addLog(`${gameData.player1.name} gains +1‚öôÔ∏è from Metal Tier I`);
                }
                
                if (gameData.player2.metalTier >= 1) {
                    updates['player2/metal'] = gameData.player2.metal + 1;
                    addLog(`${gameData.player2.name} gains +1‚öôÔ∏è from Metal Tier I`);
                }
                
                if (Object.keys(updates).length > 0) {
                    gameRef.update(updates);
                }
            });
        }
        
        function applyEndOfRoundEffects() {
            if (localPlayer.playerNumber !== 1) return; // Only player 1 applies effects
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const updates = {};
                
                if (gameData.player1.metalTier >= 3) {
                    updates['player1/vp'] = gameData.player1.vp + 2;
                    addLog(`${gameData.player1.name} gains +2 VP from Metal Tier III`);
                }
                
                if (gameData.player2.metalTier >= 3) {
                    updates['player2/vp'] = gameData.player2.vp + 2;
                    addLog(`${gameData.player2.name} gains +2 VP from Metal Tier III`);
                }
                
                if (gameData.player1.energyTier >= 3) {
                    updates['player1/vp'] = (updates['player1/vp'] || gameData.player1.vp) + 1;
                    addLog(`${gameData.player1.name} gains +1 VP from Energy Tier III`);
                }
                
                if (gameData.player2.energyTier >= 3) {
                    updates['player2/vp'] = (updates['player2/vp'] || gameData.player2.vp) + 1;
                    addLog(`${gameData.player2.name} gains +1 VP from Energy Tier III`);
                }
                
                // Reset per-round flags
                updates['player1/usedInsightEffect'] = false;
                updates['player1/usedEnergyEffect'] = false;
                updates['player2/usedInsightEffect'] = false;
                updates['player2/usedEnergyEffect'] = false;
                
                if (Object.keys(updates).length > 0) {
                    gameRef.update(updates);
                }
            });
        }
        
        function checkWinCondition() {
            if (localPlayer.playerNumber !== 1) return; // Only player 1 checks
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                
                const checkPlayer = (playerData, playerName) => {
                    if (playerData.metal >= 12) {
                        return { player: playerName, condition: 'Industrial Revolution (12+ Metal)' };
                    }
                    
                    if (playerData.vp >= 18) {
                        return { player: playerName, condition: 'Victory Points (18 VP)' };
                    }
                    
                    const complete = (playerData.metalTier >= 3 ? 1 : 0) + 
                                    (playerData.energyTier >= 3 ? 1 : 0) + 
                                    (playerData.insightTier >= 3 ? 1 : 0);
                    if (complete >= 3) {
                        return { player: playerName, condition: 'Engine Mastery (3 families)' };
                    }
                    
                    return null;
                };
                
                const winner = checkPlayer(gameData.player1, gameData.player1.name) || 
                              checkPlayer(gameData.player2, gameData.player2.name);
                
                if (winner) {
                    gameRef.update({
                        status: 'finished',
                        winner: winner
                    });
                } else {
                    // Start next round
                    startNextRound();
                }
            });
        }
        
        function startNextRound() {
            if (localPlayer.playerNumber !== 1) return; // Only player 1 starts rounds
            
            gameRef.once('value').then(snapshot => {
                const gameData = snapshot.val();
                const newRound = gameData.round + 1;
                const firstPicker = newRound % 2 === 1 ? 1 : 2; // Alternate who goes first
                
                gameRef.update({
                    round: newRound,
                    phase: 'rolling',
                    dice: rollDice(),
                    player1Dice: [],
                    player2Dice: [],
                    currentPlayer: firstPicker,
                    'player1/actionComplete': false,
                    'player2/actionComplete': false,
                    'player1/usedInsightEffect': false,
                    'player2/usedInsightEffect': false,
                    'player1/usedEnergyEffect': false,
                    'player2/usedEnergyEffect': false,
                    'player1/waitingForDraftEffect': false,
                    'player2/waitingForDraftEffect': false
                });
                
                addLog(`Round ${newRound} started!`);
                addLog(`${gameData['player' + firstPicker].name} picks first this round`);
                
                applyStartOfRoundEffects();
                
                setTimeout(() => {
                    gameRef.update({
                        phase: 'player' + firstPicker + 'Pick1'
                    });
                }, 1000);
            });
        }
        
        function showGameOver(gameData) {
            const modal = document.getElementById('gameOverModal');
            const content = document.getElementById('gameOverContent');
            
            const winner = gameData.winner;
            const isWinner = winner.player === localPlayer.name;
            
            content.innerHTML = `
                <h3 style="text-align: center; margin-bottom: 20px;">${isWinner ? 'üéâ' : 'üíÄ'} ${winner.player} WINS!</h3>
                <p style="text-align: center; font-size: 1.2em; margin-bottom: 20px;">${winner.condition}</p>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>${gameData.player1.name}</h3>
                        <p>Resources: ‚öôÔ∏è${gameData.player1.metal} üå±${gameData.player1.energy} üìò${gameData.player1.insight}</p>
                        <p>VP: ${gameData.player1.vp}</p>
                        <p>Engines: M${gameData.player1.metalTier}E${gameData.player1.energyTier}I${gameData.player1.insightTier}</p>
                    </div>
                    
                    <div class="stat-card">
                        <h3>${gameData.player2.name}</h3>
                        <p>Resources: ‚öôÔ∏è${gameData.player2.metal} üå±${gameData.player2.energy} üìò${gameData.player2.insight}</p>
                        <p>VP: ${gameData.player2.vp}</p>
                        <p>Engines: M${gameData.player2.metalTier}E${gameData.player2.energyTier}I${gameData.player2.insightTier}</p>
                    </div>
                </div>
                
                <p style="text-align: center; margin-top: 20px;">Game Length: ${gameData.round} rounds</p>
            `;
            
            modal.style.display = 'block';
        }
        
        function addLog(message) {
            if (!gameRef) return;
            
            // Use transaction to prevent race conditions
            gameRef.child('logs').transaction(function(currentLogs) {
                if (!currentLogs) {
                    currentLogs = [];
                }
                
                // Check if this exact message was just added (prevent duplicates)
                if (currentLogs.length > 0) {
                    const lastLog = currentLogs[currentLogs.length - 1];
                    if (lastLog && lastLog.includes(message)) {
                        console.log('Prevented duplicate log:', message);
                        return currentLogs; // Don't modify
                    }
                }
                
                // Use move number
                const moveNumber = currentLogs.length + 1;
                currentLogs.push(`${moveNumber}. ${message}`);
                
                // Keep only last 100 logs
                if (currentLogs.length > 100) {
                    currentLogs = currentLogs.slice(-100);
                }
                
                return currentLogs;
            });
        }
        
        function leaveGame() {
            if (gameListener) {
                gameRef.off('value', gameListener);
            }
            
            if (currentGameId && gameRef) {
                const playerKey = 'player' + localPlayer.playerNumber;
                
                // Mark as disconnected
                gameRef.child(playerKey).child('connected').set(false);
                
                // If game hasn't started, mark as abandoned
                gameRef.once('value').then(snapshot => {
                    const gameData = snapshot.val();
                    if (gameData && (gameData.status === 'waiting' || gameData.status === 'ready')) {
                        gameRef.update({ status: 'abandoned' });
                        // Delete after a moment
                        setTimeout(() => {
                            gameRef.remove();
                        }, 1000);
                    }
                });
            }
            
            clearSession();
            backToLobby();
        }
        
        function backToLobby() {
            if (gameListener) {
                gameRef.off('value', gameListener);
                gameListener = null;
            }
            
            currentGameId = null;
            gameRef = null;
            
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('waitingRoom').classList.add('hidden');
            document.getElementById('gameOverModal').style.display = 'none';
            document.getElementById('gameSelectionScreen').classList.remove('hidden');
            
            refreshGameList();
        }
        
        // Connection monitoring
        database.ref('.info/connected').on('value', snapshot => {
            const status = document.getElementById('connectionStatus');
            if (snapshot.val() === true) {
                status.textContent = 'üü¢ Connected';
                status.classList.remove('disconnected');
            } else {
                status.textContent = 'üî¥ Disconnected';
                status.classList.add('disconnected');
            }
        });
        
        // Cleanup old games periodically
        function cleanupOldGames() {
            const oneHourAgo = Date.now() - (60 * 60 * 1000);
            
            database.ref('games').once('value').then(snapshot => {
                const updates = {};
                
                snapshot.forEach(childSnapshot => {
                    const game = childSnapshot.val();
                    const gameId = childSnapshot.key;
                    
                    // Remove abandoned games or very old waiting games
                    if (game.status === 'abandoned' || 
                        (game.status === 'waiting' && game.createdAt < oneHourAgo)) {
                        updates[gameId] = null; // Delete
                    }
                });
                
                if (Object.keys(updates).length > 0) {
                    database.ref('games').update(updates);
                    console.log('Cleaned up', Object.keys(updates).length, 'old games');
                }
            });
        }
        
        // Run cleanup every 5 minutes
        setInterval(cleanupOldGames, 5 * 60 * 1000);
        // Also run on load
        setTimeout(cleanupOldGames, 5000);
        
        // Auto-start game when both players ready
        function setupAutoStart() {
            if (localPlayer.playerNumber === 1) {
                gameRef.on('value', snapshot => {
                    const gameData = snapshot.val();
                    if (gameData && gameData.status === 'active' && gameData.round === 0) {
                        setTimeout(() => startGame(), 2000);
                    }
                });
            }
        }
    </script>
</body>
</html>
